Under a common mental model of transactions, you might imagine that when you read the organisation in query (3), you'll get the same result as in query (2).

That's not the case in read committed- there is no guarantee that a different transaction didn't update bananas after (2), but before (3), causing your version of bananas to change even while within your own transaction.

This phenomenon is called a non-repeatable read, when a transaction reading the same data can receive different results. In my experience, most developers believe transactions will prevent this, which can have nasty consequences.

So if read committed transactions don't provide a stable snapshot of the world, what do we use them for?

Transactions should be used to make one-or-more changes that should be either accepted or rejected together (an atomic change) when it wouldn't be appropriate for other users of the database to see any in-between state.

If you want repeatable reads in a read committed world, you'll need to add some locking.

Under a common mental model of transactions, you might imagine that when you read the organisation in query (3), you'll get the same result as in query (2).

That's not the case in read committed- there is no guarantee that a different transaction didn't update bananas after (2), but before (3), causing your version of bananas to change even while within your own transaction.

This phenomenon is called a non-repeatable read, when a transaction reading the same data can receive different results. In my experience, most developers believe transactions will prevent this, which can have nasty consequences.

So if read committed transactions don't provide a stable snapshot of the world, what do we use them for?

Transactions should be used to make one-or-more changes that should be either accepted or rejected together (an atomic change) when it wouldn't be appropriate for other users of the database to see any in-between state.

If you want repeatable reads in a read committed world, you'll need to add some locking.

Under a common mental model of transactions, you might imagine that when you read the organisation in query (3), you'll get the same result as in query (2).

That's not the case in read committed- there is no guarantee that a different transaction didn't update bananas after (2), but before (3), causing your version of bananas to change even while within your own transaction.

This phenomenon is called a non-repeatable read, when a transaction reading the same data can receive different results. In my experience, most developers believe transactions will prevent this, which can have nasty consequences.

So if read committed transactions don't provide a stable snapshot of the world, what do we use them for?

Transactions should be used to make one-or-more changes that should be either accepted or rejected together (an atomic change) when it wouldn't be appropriate for other users of the database to see any in-between state.

If you want repeatable reads in a read committed world, you'll need to add some locking.